// -*- mode: c -*-

#include "../tools/lexer.h"
#include "arith.declarations.h"

#include "../tools/lexer.re2c.h"

#include <assert.h>
#include <stddef.h>
#include <stdlib.h>

lexer_t arith_lexer_re2c_create(void);
void arith_lexer_re2c_destroy(lexer_t);
bool arith_lexer_re2c_valid(lexer_t);
lexer_token_t arith_lexer_re2c_iterator_step(lexer_t, lexer_iterator_t*);


lexer_token_t arith_lexer_re2c_iterator_step(lexer_t lex,
                                             lexer_iterator_t* iter)
{
  (void)lex;

  const char* YYCURSOR = iter->cursor;
  const char* YYLIMIT = iter->end;
  const char* YYMARKER;

  enum arith_token id = arith_token_UNKNOWN;

// re2c begin /*!re2c
      re2c:define:YYCTYPE = char;
      re2c:yyfill:enable = 0;
      
      // not delighted with a nul ending the string
      // I think re2c:eof = -1, deleting the $ rule and adding a bunch
      // of noise like re2c:define:YYPEEK allows dropping that constraint,
      // probably with a performance cost
      
      re2c:eof = 0; 
      re2c:indent:string = "  ";

      // rec2:header is unused, don't need to generate a header

      re2c:label:prefix = "re2c"; // yy is overused in lexers

      // Could give them all variable names
      INTEGER = "0|-*[1-9]+[0-9]*";
      WHITESPACE = "[[:space:]]+";

      // The regex {block} is constrained by re2c
      "[+]"      { id = arith_token_PLUS;       goto match; }
      "[-]"      { id = arith_token_MINUS;      goto match; }
      "[*]"      { id = arith_token_TIMES;      goto match; }
      "[/]"      { id = arith_token_DIVIDE;     goto match; }
      "[%]"      { id = arith_token_MODULO;     goto match; }
      "\("       { id = arith_token_LPAREN;     goto match; }
      "\)"       { id = arith_token_RPAREN;     goto match; }
      INTEGER    { id = arith_token_INTEGER;    goto match; }
      WHITESPACE { id = arith_token_WHITESPACE; goto match; }

      "." { id = arith_token_UNKNOWN; goto match; }
      *    { goto failure; }
      $    { goto failure; }
  */// re2c finish

  // If we got here with none matching id is still unknown but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:
  assert(id == arith_token_UNKNOWN);
  YYCURSOR = iter->cursor;

match:;
  size_t width = YYCURSOR - iter->cursor;
  *iter = (lexer_iterator_t){.cursor = iter->cursor + width, .end = iter->end};
  return (lexer_token_t){
      .id = (size_t)id,
      .value = iter->cursor,
      .width = width,
  };
}
