// -*- mode: c -*-

#include "../tools/lexer.h"
#include "arith.declarations.h"

#include <assert.h>
#include <stddef.h>
#include <stdlib.h>

lexer_t arith_lexer_re2c_create(void);
void arith_lexer_re2c_destroy(lexer_t);
bool arith_lexer_re2c_valid(lexer_t);
lexer_token_t arith_lexer_re2c_iterator_step(lexer_t, lexer_iterator_t*);

typedef struct
{
#ifndef NDEBUG
  enum lexer_engines engine;
#else
  char unused;
#endif
} re2c_lexer;

static void set_engine(re2c_lexer* l)
{
#ifndef NDEBUG
  l->engine = lexer_engines_re2c;
#else
  (void)l;
#endif
}

static void check_engine(re2c_lexer* l)
{
#ifndef NDEBUG
  if (l != NULL)
    {
      unsigned num = l->engine;
      if (num != lexer_engines_re2c)
        {
          fprintf(stderr,
                  "Invalid magic number (%u) for lexer.re2c, aborting\n", num);
          abort();
        }
    }
#else
  (void)l;
#endif
}

static lexer_t from_re2c(re2c_lexer* l)
{
  check_engine(l);
  return (lexer_t){.data = (void*)l};
}

static re2c_lexer* to_re2c(lexer_t l)
{
  re2c_lexer* lexer = (re2c_lexer*)l.data;
  check_engine(lexer);
  return lexer;
}

lexer_t arith_lexer_re2c_create(void)
{
  static re2c_lexer only = {0};
  set_engine(&only);
  check_engine(&only);
  return from_re2c(&only);
}

void arith_lexer_re2c_destroy(lexer_t l)
{
  re2c_lexer* lexer = to_re2c(l);
  (void)lexer;
}

bool arith_lexer_re2c_valid(lexer_t l)
{
  re2c_lexer* lexer = to_re2c(l);
  (void)lexer;
  return true;
}

lexer_token_t arith_lexer_re2c_iterator_step(lexer_t lex,
                                             lexer_iterator_t* iter)
{
  check_engine(to_re2c(lex));

  const char* YYCURSOR = iter->cursor;
  const char* YYLIMIT = iter->end;
  const char* YYMARKER;

  enum arith_token id = arith_token_UNKNOWN;

// re2c begin /*!re2c
      re2c:define:YYCTYPE = char;
      re2c:yyfill:enable = 0;
      
      // not delighted with a nul ending the string
      // I think re2c:eof = -1, deleting the $ rule and adding a bunch
      // of noise like re2c:define:YYPEEK allows dropping that constraint,
      // probably with a performance cost
      
      re2c:eof = 0; 
      re2c:indent:string = "  ";

      // rec2:header is unused, don't need to generate a header

      re2c:label:prefix = "re2c"; // yy is overused in lexers

      // Could give them all variable names
      INTEGER = "0|-*[1-9]+[0-9]*";
      WHITESPACE = "[[:space:]]+";

      // The regex {block} is constrained by re2c
      "[+]"      { id = arith_token_PLUS;       goto match; }
      "[-]"      { id = arith_token_MINUS;      goto match; }
      "[*]"      { id = arith_token_TIMES;      goto match; }
      "[/]"      { id = arith_token_DIVIDE;     goto match; }
      "[%]"      { id = arith_token_MODULO;     goto match; }
      "\("       { id = arith_token_LPAREN;     goto match; }
      "\)"       { id = arith_token_RPAREN;     goto match; }
      INTEGER    { id = arith_token_INTEGER;    goto match; }
      WHITESPACE { id = arith_token_WHITESPACE; goto match; }

      "." { id = arith_token_UNKNOWN; goto match; }
      *    { goto failure; }
      $    { goto failure; }
  */// re2c finish

  // If we got here with none matching id is still unknown but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:
  assert(id == arith_token_UNKNOWN);
  YYCURSOR = iter->cursor;

match:;
  size_t width = YYCURSOR - iter->cursor;
  *iter = (lexer_iterator_t){.cursor = iter->cursor + width, .end = iter->end};
  return (lexer_token_t){
      .id = (size_t)id,
      .value = iter->cursor,
      .width = width,
  };
}